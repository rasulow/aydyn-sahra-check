<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫–∞–∑–æ–≤ - –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'main/css/sargyt_check.css' %}">
    <!-- SheetJS library with styling support for Excel export -->
    <script src="{% static 'main/js/xlsx-js-style.min.js' %}"></script>
</head>
<body>
    <div class="container">
        <a href="{% url 'main:home' %}" class="back-btn">‚Üê –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a>
        
        <div class="header">
            <h1>–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫–∞–∑–æ–≤</h1>
            <p>–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤</p>
        </div>

        <!-- Initial Add Order Button -->
        <div class="initial-add-container" id="initial-add-container">
            <button class="add-table-btn" id="initial-add-order-btn" onclick="openUserDataModal()">
                <span class="btn-icon">+</span>
                <span class="btn-text">–î–æ–±–∞–≤–∏—Ç—å –∑–∞–∫–∞–∑</span>
            </button>
        </div>

        <!-- Container for all tables - initially hidden -->
        <div id="tables-wrapper" style="display: none;">
        
        <div class="table-container" data-table-number="1" style="display: none;">
            <div class="table-header">
                <h3 class="table-title">–ó–∞–∫–∞–∑ ‚Ññ1</h3>
                <button class="delete-table-btn" onclick="deleteTable(this)" title="–£–¥–∞–ª–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É">‚úï</button>
            </div>
            <table class="order-table" id="order-table">
                <thead>
                    <tr>
                        <th>‚Ññ</th>
                        <th>Ini</th>
                        <th>Boyy</th>
                        <th>Karniz</th>
                        <th>Category</th>
                        <th>Kod renk</th>
                        <th>Selpe</th>
                        <th>Bellik</th>
                        <th>m¬≤</th>
                        <th class="price-header">Price</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <tr class="table-row" data-row-number="1">
                        <td class="row-number">1</td>
                        <td><input type="number" class="table-input" step="0.01" placeholder="0.00"></td>
                        <td><input type="number" class="table-input" step="0.01" placeholder="0.00"></td>
                        <td>
                            <select class="table-select karniz-select">
                                <option value="">–í—ã–±–µ—Ä–∏—Ç–µ...</option>
                                <option value="mata">Dine mata</option>
                                <option value="karniz_komplekt">Karniz komplekt</option>
                            </select>
                        </td>
                        <td>
                            <select class="table-select category-select">
                                <option value="">–í—ã–±–µ—Ä–∏—Ç–µ...</option>
                            </select>
                        </td>
                        <td>
                            <div class="searchable-select-wrapper">
                                <input type="text" class="table-input kodrenk-search" placeholder="–ù–∞—á–Ω–∏—Ç–µ –≤–≤–æ–¥–∏—Ç—å..." autocomplete="off">
                                <div class="kodrenk-dropdown"></div>
                            </div>
                        </td>
                        <td>
                            <select class="table-select selpe-select">
                                <option value="">-</option>
                            </select>
                        </td>
                        <td><input type="text" class="table-input" placeholder="–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ"></td>
                        <td class="meter-square">0.00</td>
                        <td class="row-price">0.00</td>
                        <td>
                            <button class="remove-row-btn" onclick="removeRow(this)">‚úï</button>
                        </td>
                    </tr>
                </tbody>
            </table>
            
            <!-- Total Price Display -->
            <div class="total-price-container">
                <div class="total-price-row">
                    <span class="total-price-label">–ò—Ç–æ–≥–æ:</span>
                    <span class="total-price-value">0.00</span>
                </div>
            </div>
            
            <div class="table-buttons">
                <button class="add-row-btn" id="add-row-btn" onclick="addNewRow()">
                    <span class="btn-icon">+</span>
                    <span class="btn-text">–î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É</span>
                </button>
                <button class="add-table-btn" id="add-table-btn" onclick="addNewTable()">
                    <span class="btn-icon">+</span>
                    <span class="btn-text">–î–æ–±–∞–≤–∏—Ç—å –∑–∞–∫–∞–∑</span>
                </button>
                <button class="download-btn" id="download-btn" onclick="downloadAsExcel()">
                    <span class="btn-icon">üì•</span>
                    <span class="btn-text">–°–∫–∞—á–∞—Ç—å Excel</span>
                </button>
            </div>
        </div>
        
        </div><!-- End tables-wrapper -->
    </div>

    <!-- Modal for User Data Input -->
    <div id="user-data-modal" class="modal">
        <div class="modal-content">
            <h3 class="modal-title">–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑–∞</h3>
            <div class="user-data-form">
                <div class="selection-group">
                    <label for="modal-user-select">–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</label>
                    <div class="user-select-with-button">
                        <div class="searchable-select">
                            <input type="text" 
                                   id="modal-user-select" 
                                   class="select-input" 
                                   placeholder="–ù–∞—á–Ω–∏—Ç–µ –≤–≤–æ–¥–∏—Ç—å –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è..." 
                                   autocomplete="off">
                            <div id="modal-user-dropdown" class="dropdown-list"></div>
                        </div>
                        <button type="button" class="add-user-btn" onclick="openAddUserModal()">
                            <span class="btn-icon">+</span>
                            <span class="btn-text">–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</span>
                        </button>
                    </div>
                </div>
                
                <div class="selection-group">
                    <label for="modal-user-region">–†–µ–≥–∏–æ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</label>
                    <input type="text" 
                           id="modal-user-region" 
                           class="region-display" 
                           placeholder="–†–µ–≥–∏–æ–Ω –±—É–¥–µ—Ç –≤—ã–±—Ä–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏" 
                           readonly>
                </div>
                
                <div class="selection-group">
                    <label for="modal-currency-select">–í–∞–ª—é—Ç–∞:</label>
                    <select id="modal-currency-select" class="region-select">
                        <option value="USD">USD</option>
                        <option value="TMT">TMT</option>
                    </select>
                </div>
            </div>
            <div class="modal-action-buttons">
                <button class="modal-btn modal-btn-confirm" onclick="confirmUserData()">–î–æ–±–∞–≤–∏—Ç—å</button>
                <button class="modal-btn modal-btn-cancel" onclick="closeUserDataModal()">–û—Ç–º–µ–Ω–∞</button>
            </div>
        </div>
    </div>

    <!-- Modal for Weranda selection -->
    <div id="weranda-modal" class="modal">
        <div class="modal-content">
            <h3 class="modal-title">–î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É</h3>
            <p class="modal-question">–≠—Ç–æ Weranda?</p>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-yes" onclick="handleWerandaYes()">–î–∞</button>
                <button class="modal-btn modal-btn-no" onclick="handleWerandaNo()">–ù–µ—Ç</button>
            </div>
            <div id="weranda-options" class="weranda-options" style="display: none;">
                <label for="weranda-type-select">–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø:</label>
                <select id="weranda-type-select" class="modal-select">
                    <option value="">–í—ã–±–µ—Ä–∏—Ç–µ...</option>
                    <option value="2-bolek">2 bolek</option>
                    <option value="3-bolek">3 bolek</option>
                    <option value="4-bolek">4 bolek</option>
                </select>
                <div class="modal-action-buttons">
                    <button class="modal-btn modal-btn-confirm" onclick="confirmWerandaRow()">–î–æ–±–∞–≤–∏—Ç—å</button>
                    <button class="modal-btn modal-btn-cancel" onclick="closeWerandaModal()">–û—Ç–º–µ–Ω–∞</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Adding New User -->
    <div id="add-user-modal" class="modal">
        <div class="modal-content modal-content-small">
            <h3 class="modal-title">–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</h3>
            <div class="user-data-form">
                <div class="selection-group">
                    <label for="new-user-name">–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</label>
                    <input type="text" 
                           id="new-user-name" 
                           class="text-input" 
                           placeholder="–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è..." 
                           autocomplete="off">
                </div>
                
                <div class="selection-group">
                    <label for="new-user-region">–†–µ–≥–∏–æ–Ω:</label>
                    <select id="new-user-region" class="region-select">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–≥–∏–æ–Ω...</option>
                    </select>
                </div>
                
                <div class="selection-group">
                    <label for="new-user-client-type">–¢–∏–ø –∫–ª–∏–µ–Ω—Ç–∞:</label>
                    <select id="new-user-client-type" class="region-select">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–ª–∏–µ–Ω—Ç–∞...</option>
                    </select>
                </div>
            </div>
            <div class="modal-action-buttons">
                <button class="modal-btn modal-btn-confirm" onclick="confirmAddUser()">–î–æ–±–∞–≤–∏—Ç—å</button>
                <button class="modal-btn modal-btn-cancel" onclick="closeAddUserModal()">–û—Ç–º–µ–Ω–∞</button>
            </div>
        </div>
    </div>

    <script>
        // Load clients data from backend
        const users = {{ clients_json|safe }};
        const karnizOptions = {{ karniz_json|safe }};
        const selpeOptions = {{ selpe_json|safe }};
        const regions = {{ regions_json|safe }};
        const clientTypes = {{ client_types_json|safe }};

        // Modal elements
        const modalUserInput = document.getElementById('modal-user-select');
        const modalUserDropdown = document.getElementById('modal-user-dropdown');
        const modalRegionDisplay = document.getElementById('modal-user-region');
        
        let modalSelectedUser = null;
        let modalSelectedCurrency = 'USD'; // Default currency
        let currentTableUserData = {}; // Store user data for each table
        
        // Populate region dropdown in add user modal
        function populateRegionDropdown() {
            const regionSelect = document.getElementById('new-user-region');
            regionSelect.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–≥–∏–æ–Ω...</option>';
            
            regions.forEach(region => {
                const option = document.createElement('option');
                option.value = region.id;
                option.textContent = region.name;
                regionSelect.appendChild(option);
            });
        }
        
        // Populate client type dropdown in add user modal
        function populateClientTypeDropdown() {
            const clientTypeSelect = document.getElementById('new-user-client-type');
            clientTypeSelect.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–ª–∏–µ–Ω—Ç–∞...</option>';
            
            clientTypes.forEach(clientType => {
                const option = document.createElement('option');
                option.value = clientType.id;
                option.textContent = clientType.type;
                clientTypeSelect.appendChild(option);
            });
        }
        
        // Initialize dropdowns on page load
        document.addEventListener('DOMContentLoaded', function() {
            populateRegionDropdown();
            populateClientTypeDropdown();
        });

        // Open user data modal
        function openUserDataModal() {
            const modal = document.getElementById('user-data-modal');
            modal.classList.add('show');
        }

        // Close user data modal
        function closeUserDataModal() {
            const modal = document.getElementById('user-data-modal');
            modal.classList.remove('show');
            
            // Reset modal inputs
            modalUserInput.value = '';
            modalRegionDisplay.value = '';
            modalSelectedUser = null;
            document.getElementById('modal-currency-select').value = 'USD';
        }
        
        // Open add user modal (nested modal)
        function openAddUserModal() {
            const addUserModal = document.getElementById('add-user-modal');
            addUserModal.classList.add('show');
            
            // Keep the main modal open (don't close it)
        }
        
        // Close add user modal
        function closeAddUserModal() {
            const addUserModal = document.getElementById('add-user-modal');
            addUserModal.classList.remove('show');
            
            // Reset inputs
            document.getElementById('new-user-name').value = '';
            document.getElementById('new-user-region').selectedIndex = 0;
            document.getElementById('new-user-client-type').selectedIndex = 0;
        }
        
        // Get CSRF token for Django
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        // Confirm add user - save to database via AJAX
        async function confirmAddUser() {
            const userName = document.getElementById('new-user-name').value.trim();
            const regionSelect = document.getElementById('new-user-region');
            const regionId = regionSelect.value;
            const regionName = regionSelect.selectedOptions[0]?.text;
            const clientTypeSelect = document.getElementById('new-user-client-type');
            const clientTypeId = clientTypeSelect.value || null;
            
            // Validate inputs
            if (!userName) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!');
                return;
            }
            
            if (!regionId) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–≥–∏–æ–Ω!');
                return;
            }
            
            // Prepare data for server
            const data = {
                name: userName,
                region_id: parseInt(regionId),
                client_type_id: clientTypeId ? parseInt(clientTypeId) : null
            };
            
            try {
                // Send request to server
                const response = await fetch('{% url "main:add_client" %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Create new user object with real ID from database
                    const newUser = {
                        id: result.client.id,
                        name: result.client.name,
                        region: result.client.region
                    };
                    
                    // Add to users array
                    users.push(newUser);
                    
                    // Automatically select the new user in the main modal
                    selectModalUser(newUser);
                    
                    // Close add user modal
                    closeAddUserModal();
                    
                    console.log('–ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö:', newUser);
                    
                    // Show success message
                    alert(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å "${userName}" —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!`);
                } else {
                    // Show error message from server
                    alert('–û—à–∏–±–∫–∞: ' + result.error);
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
                alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
            }
        }

        // Get client type ID for a specific table
        function getClientTypeForTable(tableContainer) {
            const tableNumber = Array.from(document.querySelectorAll('.table-container')).indexOf(tableContainer) + 1;
            const userData = currentTableUserData[tableNumber];
            
            if (!userData || !userData.user) {
                return null;
            }
            
            // Find the user's client_type_id from the users array
            const user = users.find(u => u.id === userData.user.id);
            if (!user) return null;
            
            // Find the full client object to get client_type_id
            const clients = {{ clients_json|safe }};
            const clientData = clients.find(c => c.id === user.id);
            return clientData ? clientData.client_type_id : null;
        }
        
        // Get currency for a specific table
        function getCurrencyForTable(tableContainer) {
            const tableNumber = Array.from(document.querySelectorAll('.table-container')).indexOf(tableContainer) + 1;
            const userData = currentTableUserData[tableNumber];
            const currency = userData && userData.currency ? userData.currency : 'USD';
            console.log('getCurrencyForTable - Table:', tableNumber, 'Currency:', currency, 'UserData:', userData);
            return currency;
        }
        
        // Calculate row price based on ini, boyy, kod renk, and selpe
        function calculateRowPrice(row, clientType) {
            const iniInput = row.querySelector('td:nth-child(2) input');
            const boyyInput = row.querySelector('td:nth-child(3) input');
            const kodRenkInput = row.querySelector('.kodrenk-search');
            const karnizSelect = row.querySelector('.karniz-select');
            const categorySelect = row.querySelector('.category-select');
            const selpeSelect = row.querySelector('.selpe-select');
            
            const ini = parseFloat(iniInput.value) || 0;
            const boyy = parseFloat(boyyInput.value) || 0;
            const kodRenkCode = kodRenkInput.value.trim();
            const karnizValue = karnizSelect ? karnizSelect.value : '';
            const categoryId = categorySelect ? parseInt(categorySelect.value) : null;
            const selpeId = selpeSelect ? parseInt(selpeSelect.value) : null;
            
            // Get currency for this table
            const tableContainer = row.closest('.table-container');
            const currency = getCurrencyForTable(tableContainer);
            console.log('calculateRowPrice - Using currency:', currency);
            
            let totalPrice = 0;
            
            // Calculate color price (area-based)
            if (ini && boyy && kodRenkCode) {
                // Find the color data
                const colorData = kodRenks.find(kr => kr.code === kodRenkCode);
                if (colorData) {
                    let priceUSD = 0;
                    let priceTMT = 0;
                    
                    // If Karniz is set to "mata", always use mata prices regardless of client type
                    if (karnizValue === 'mata') {
                        priceUSD = colorData.mata_USD || 0;
                        priceTMT = colorData.mata_TMT || 0;
                    } else {
                        // Determine which price to use based on client type ID
                        // 1 -> diller, 2 -> mary diller, 3 -> bez ustanowka
                        if (clientType === 1) {
                            // ID 1: diller
                            priceUSD = colorData.diller_USD || 0;
                            priceTMT = colorData.diller_TMT || 0;
                        } else if (clientType === 2) {
                            // ID 2: mary diller
                            priceUSD = colorData.mary_diller_USD || 0;
                            priceTMT = colorData.mary_diller_TMT || 0;
                        } else if (clientType === 3) {
                            // ID 3: bez ustanowka
                            priceUSD = colorData.bez_ustanowka_USD || 0;
                            priceTMT = colorData.bez_ustanowka_TMT || 0;
                        } else {
                            // Default to "mata" prices if no client type
                            priceUSD = colorData.mata_USD || 0;
                            priceTMT = colorData.mata_TMT || 0;
                        }
                    }
                    
                    let area = ini * boyy;
                    
                    // Special rule for category ID 6: if 0.7 <= area < 1, round to 1
                    if (categoryId === 6 && area >= 0.7 && area < 1) {
                        area = 1;
                    }
                    
                    // Use the selected currency
                    const selectedPrice = currency === 'USD' ? priceUSD : priceTMT;
                    console.log('Price calculation - Currency:', currency, 'USD:', priceUSD, 'TMT:', priceTMT, 'Selected:', selectedPrice);
                    totalPrice += area * selectedPrice;
                    
                    // Update meter square display in the row
                    const meterSquareCell = row.querySelector('.meter-square');
                    if (meterSquareCell) {
                        meterSquareCell.textContent = area.toFixed(2);
                    }
                }
            }
            
            // Add Selpe price if selected
            if (selpeId) {
                const selpeData = selpeOptions.find(s => s.id === selpeId);
                if (selpeData) {
                    totalPrice += currency === 'USD' ? (selpeData.price_USD || 0) : (selpeData.price_TMT || 0);
                }
            }
            
            // Update row price display
            const rowPriceCell = row.querySelector('.row-price');
            if (rowPriceCell) {
                if (currency === 'USD') {
                    rowPriceCell.textContent = '$' + totalPrice.toFixed(2);
                } else {
                    rowPriceCell.textContent = totalPrice.toFixed(2) + ' TMT';
                }
            }
            
            return totalPrice;
        }
        
        // Calculate and update table totals
        function updateTableTotals(tableContainer) {
            const tbody = tableContainer.querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            let total = 0;
            
            // Get client type and currency for this table
            const clientType = getClientTypeForTable(tableContainer);
            const currency = getCurrencyForTable(tableContainer);
            
            // Calculate total from all rows
            rows.forEach(row => {
                const price = calculateRowPrice(row, clientType);
                total += price;
            });
            
            // Update the display
            const totalDisplay = tableContainer.querySelector('.total-price-value');
            const totalLabel = tableContainer.querySelector('.total-price-label');
            
            if (totalDisplay) {
                if (currency === 'USD') {
                    totalDisplay.textContent = '$' + total.toFixed(2);
                } else {
                    totalDisplay.textContent = total.toFixed(2) + ' TMT';
                }
            }
            
            if (totalLabel) {
                totalLabel.textContent = `–ò—Ç–æ–≥–æ (${currency}):`;
            }
            
            // Update table header
            const priceHeader = tableContainer.querySelector('.price-header');
            if (priceHeader) {
                priceHeader.textContent = `Price (${currency})`;
            }
        }
        
        // Setup calculation listeners for a row
        function setupRowCalculationListeners(row) {
            const iniInput = row.querySelector('td:nth-child(2) input');
            const boyyInput = row.querySelector('td:nth-child(3) input');
            const kodRenkInput = row.querySelector('.kodrenk-search');
            const karnizSelect = row.querySelector('.karniz-select');
            const selpeSelect = row.querySelector('.selpe-select');
            
            const tableContainer = row.closest('.table-container');
            
            // Add input listeners
            [iniInput, boyyInput, kodRenkInput].forEach(input => {
                if (input) {
                    input.addEventListener('input', () => {
                        updateTableTotals(tableContainer);
                    });
                    // Also listen for blur events for kodRenkInput
                    if (input === kodRenkInput) {
                        input.addEventListener('blur', () => {
                            setTimeout(() => updateTableTotals(tableContainer), 200);
                        });
                    }
                }
            });
            
            // Add change listener for karniz select
            if (karnizSelect) {
                karnizSelect.addEventListener('change', () => {
                    updateTableTotals(tableContainer);
                });
            }
            
            // Add change listener for selpe select
            if (selpeSelect) {
                selpeSelect.addEventListener('change', () => {
                    updateTableTotals(tableContainer);
                });
            }
        }
        
        // Initialize calculation listeners for all existing rows
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.table-container').forEach(tableContainer => {
                const rows = tableContainer.querySelectorAll('tbody tr');
                rows.forEach(row => setupRowCalculationListeners(row));
                updateTableTotals(tableContainer);
            });
        });

        // Add user data display to table
        function addUserDataToTable(tableContainer, tableNumber) {
            const userData = currentTableUserData[tableNumber];
            if (!userData) return;
            
            const tableHeader = tableContainer.querySelector('.table-header');
            
            // Check if user data display already exists
            let userDataDisplay = tableContainer.querySelector('.user-data-display');
            if (!userDataDisplay) {
                userDataDisplay = document.createElement('div');
                userDataDisplay.className = 'user-data-display';
                tableHeader.insertAdjacentElement('afterend', userDataDisplay);
            }
            
            userDataDisplay.innerHTML = `
                <div class="user-data-row">
                    <span class="user-data-label">User:</span>
                    <span class="user-data-value">${userData.user.name}</span>
                </div>
                <div class="user-data-row">
                    <span class="user-data-label">Region:</span>
                    <span class="user-data-value">${userData.region}</span>
                </div>
                <div class="user-data-row">
                    <span class="user-data-label">Currency:</span>
                    <span class="user-data-value">${userData.currency}</span>
                </div>
            `;
        }

        // Filter and display users based on search (for modal)
        function filterModalUsers(searchTerm) {
            const filtered = users.filter(user => 
                user.name.toLowerCase().includes(searchTerm.toLowerCase())
            );
            
            displayModalUsers(filtered);
        }

        // Display users in modal dropdown
        function displayModalUsers(userList) {
            modalUserDropdown.innerHTML = '';
            
            if (userList.length === 0) {
                modalUserDropdown.innerHTML = '<div class="dropdown-item">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>';
            } else {
                userList.forEach(user => {
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    item.textContent = user.name;
                    item.addEventListener('click', () => selectModalUser(user));
                    modalUserDropdown.appendChild(item);
                });
            }
            
            modalUserDropdown.style.display = 'block';
        }

        // Select user in modal and set region
        function selectModalUser(user) {
            modalSelectedUser = user;
            modalUserInput.value = user.name;
            modalRegionDisplay.value = user.region;
            modalRegionDisplay.classList.add('filled');
            modalUserDropdown.style.display = 'none';
            
            console.log('–í—ã–±—Ä–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –º–æ–¥–∞–ª–µ:', user.name, '–†–µ–≥–∏–æ–Ω:', user.region);
        }

        // Modal user input event listeners
        modalUserInput.addEventListener('input', function() {
            const searchTerm = this.value.trim();
            
            if (searchTerm.length > 0) {
                filterModalUsers(searchTerm);
            } else {
                modalUserDropdown.style.display = 'none';
                modalRegionDisplay.value = '';
                modalRegionDisplay.classList.remove('filled');
                modalSelectedUser = null;
            }
        });

        modalUserInput.addEventListener('focus', function() {
            if (this.value.trim().length > 0) {
                filterModalUsers(this.value.trim());
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const searchableSelect = event.target.closest('.searchable-select');
            if (!searchableSelect) {
                modalUserDropdown.style.display = 'none';
            }
        });

        // Clear selection when input is manually cleared
        modalUserInput.addEventListener('keydown', function(event) {
            if (event.key === 'Backspace' || event.key === 'Delete') {
                setTimeout(() => {
                    if (this.value.trim() === '') {
                        modalRegionDisplay.value = '';
                        modalRegionDisplay.classList.remove('filled');
                        modalSelectedUser = null;
                    }
                }, 10);
            }
        });

        console.log('–°—Ç—Ä–∞–Ω–∏—Ü–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞–∫–∞–∑–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
        console.log('–î–æ—Å—Ç—É–ø–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', users.length);

        // Load colors for table
        const kodRenks = {{ colors_json|safe }};
        
        // Load categories
        const categories = {{ categories_json|safe }};
        
        // Populate category dropdowns
        function populateCategorySelect(selectElement) {
            // Clear existing options except the first one
            selectElement.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ...</option>';
            
            // Add categories from database
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = category.name;
                selectElement.appendChild(option);
            });
        }
        
        // Populate all existing category dropdowns and setup listeners
        document.querySelectorAll('.category-select').forEach(select => {
            populateCategorySelect(select);
            setupCategoryChangeListener(select);
        });
        
        // Populate karniz dropdowns
        function populateKarnizSelect(selectElement) {
            // Clear existing options
            selectElement.innerHTML = '';
            
            // Add empty placeholder option
            const placeholderOption = document.createElement('option');
            placeholderOption.value = '';
            placeholderOption.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ...';
            selectElement.appendChild(placeholderOption);
            
            // Add static "mata" option
            const mataOption = document.createElement('option');
            mataOption.value = 'mata';
            mataOption.textContent = 'Dine mata';
            selectElement.appendChild(mataOption);
            
            // Add static "Karniz komplekt" option as second
            const komplektOption = document.createElement('option');
            komplektOption.value = 'karniz_komplekt';
            komplektOption.textContent = 'Karniz komplekt';
            selectElement.appendChild(komplektOption);
            
            // Add karniz options from database
            karnizOptions.forEach(karniz => {
                const option = document.createElement('option');
                option.value = karniz.id;
                option.textContent = karniz.name;
                selectElement.appendChild(option);
            });
        }
        
        // Handle karniz selection change to disable/enable fields
        function handleKarnizChange(karnizSelect) {
            const row = karnizSelect.closest('tr');
            const categorySelect = row.querySelector('.category-select');
            const kodRenkInput = row.querySelector('.kodrenk-search');
            const selpeSelect = row.querySelector('.selpe-select');
            
            if (karnizSelect.value === 'karniz_komplekt') {
                // Disable category, kod renk, and selpe
                categorySelect.disabled = true;
                categorySelect.value = '';
                kodRenkInput.disabled = true;
                kodRenkInput.value = '';
                selpeSelect.disabled = true;
                selpeSelect.value = '';
                
                // Add visual styling for disabled state
                categorySelect.style.backgroundColor = '#f0f0f0';
                kodRenkInput.style.backgroundColor = '#f0f0f0';
                selpeSelect.style.backgroundColor = '#f0f0f0';
            } else {
                // Enable category, kod renk, and selpe
                categorySelect.disabled = false;
                kodRenkInput.disabled = false;
                selpeSelect.disabled = false;
                
                // Remove visual styling
                categorySelect.style.backgroundColor = '';
                kodRenkInput.style.backgroundColor = '';
                selpeSelect.style.backgroundColor = '';
            }
            
            // Update table totals when karniz changes (affects price calculation)
            const tableContainer = row.closest('.table-container');
            updateTableTotals(tableContainer);
        }
        
        // Setup karniz change event listener
        function setupKarnizChangeListener(selectElement) {
            selectElement.addEventListener('change', function() {
                handleKarnizChange(this);
            });
        }
        
        // Populate selpe dropdowns
        function populateSelpeSelect(selectElement) {
            // Clear existing options except the first one
            selectElement.innerHTML = '<option value="">-</option>';
            
            // Add selpe options from database
            selpeOptions.forEach(selpe => {
                const option = document.createElement('option');
                option.value = selpe.id;
                option.textContent = selpe.name;
                selectElement.appendChild(option);
            });
        }
        
        // Populate all existing karniz dropdowns and setup listeners
        document.querySelectorAll('.karniz-select').forEach(select => {
            populateKarnizSelect(select);
            setupKarnizChangeListener(select);
        });
        
        // Populate all existing selpe dropdowns
        document.querySelectorAll('.selpe-select').forEach(select => {
            populateSelpeSelect(select);
        });

        // Close modal when clicking outside
        document.getElementById('weranda-modal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeWerandaModal();
            }
        });

        // Function to setup kod renk searchable select for table rows
        function setupKodRenkSearch(input, dropdown) {
            input.addEventListener('input', function() {
                const searchTerm = this.value.trim().toLowerCase();
                
                if (searchTerm.length > 0) {
                    // Get selected category from the same row
                    const row = this.closest('tr');
                    const categorySelect = row.querySelector('.category-select');
                    const selectedCategoryId = categorySelect.value ? parseInt(categorySelect.value) : null;
                    
                    // Filter by search term and category
                    const filtered = kodRenks.filter(kr => {
                        const matchesSearch = kr.code.toLowerCase().includes(searchTerm);
                        const matchesCategory = !selectedCategoryId || kr.category_id === selectedCategoryId;
                        return matchesSearch && matchesCategory;
                    });
                    displayKodRenkOptions(dropdown, filtered, input);
                    
                    // Check if exact match exists
                    const exactMatch = kodRenks.find(kr => kr.code.toLowerCase() === searchTerm);
                    if (exactMatch) {
                        input.style.backgroundColor = '';
                        input.style.color = '';
                    } else {
                        input.style.backgroundColor = '#ffebee';
                        input.style.color = '#c62828';
                    }
                } else {
                    dropdown.style.display = 'none';
                    input.style.backgroundColor = '';
                    input.style.color = '';
                }
            });

            input.addEventListener('focus', function() {
                if (this.value.trim().length > 0) {
                    const searchTerm = this.value.trim().toLowerCase();
                    
                    // Get selected category from the same row
                    const row = this.closest('tr');
                    const categorySelect = row.querySelector('.category-select');
                    const selectedCategoryId = categorySelect.value ? parseInt(categorySelect.value) : null;
                    
                    // Filter by search term and category
                    const filtered = kodRenks.filter(kr => {
                        const matchesSearch = kr.code.toLowerCase().includes(searchTerm);
                        const matchesCategory = !selectedCategoryId || kr.category_id === selectedCategoryId;
                        return matchesSearch && matchesCategory;
                    });
                    displayKodRenkOptions(dropdown, filtered, input);
                }
            });
        }
        
        // Setup category change listener to clear kod renk when category changes
        function setupCategoryChangeListener(categorySelect) {
            categorySelect.addEventListener('change', function() {
                const row = this.closest('tr');
                const kodRenkInput = row.querySelector('.kodrenk-search');
                // Clear kod renk input when category changes
                kodRenkInput.value = '';
            });
        }

        function displayKodRenkOptions(dropdown, kodRenkList, input) {
            dropdown.innerHTML = '';
            
            if (kodRenkList.length === 0) {
                dropdown.innerHTML = '<div class="kodrenk-item">–ö–æ–¥—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>';
            } else {
                kodRenkList.forEach(kr => {
                    const item = document.createElement('div');
                    item.className = 'kodrenk-item';
                    item.textContent = kr.code;
                    item.addEventListener('click', () => {
                        input.value = kr.code;
                        dropdown.style.display = 'none';
                        // Reset color to normal when valid code is selected
                        input.style.backgroundColor = '';
                        input.style.color = '';
                        console.log('Selected kod renk:', kr.code);
                    });
                    dropdown.appendChild(item);
                });
            }
            
            dropdown.style.display = 'block';
        }

        // Setup initial row
        document.querySelectorAll('.kodrenk-search').forEach((input) => {
            const dropdown = input.nextElementSibling;
            setupKodRenkSearch(input, dropdown);
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.searchable-select-wrapper')) {
                document.querySelectorAll('.kodrenk-dropdown').forEach(dropdown => {
                    dropdown.style.display = 'none';
                });
            }
        });

        // Global variable to store weranda type
        let currentWerandaType = null;
        let isWerandaRow = false;
        let werandaGroupCounter = 0;

        // Function to add new row - opens modal
        function addNewRow() {
            const modal = document.getElementById('weranda-modal');
            modal.classList.add('show');
        }

        // Handle Yes button click
        function handleWerandaYes() {
            document.getElementById('weranda-options').style.display = 'block';
            document.querySelector('.modal-buttons').style.display = 'none';
            isWerandaRow = true;
        }

        // Handle No button click
        function handleWerandaNo() {
            isWerandaRow = false;
            currentWerandaType = null;
            closeWerandaModal();
            actuallyAddNewRow();
        }

        // Confirm Weranda row with type
        function confirmWerandaRow() {
            const werandaTypeSelect = document.getElementById('weranda-type-select');
            currentWerandaType = werandaTypeSelect.value;
            
            if (!currentWerandaType) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø Weranda');
                return;
            }
            
            closeWerandaModal();
            actuallyAddNewRow();
        }

        // Close modal
        function closeWerandaModal() {
            const modal = document.getElementById('weranda-modal');
            modal.classList.remove('show');
            
            // Reset modal state
            document.getElementById('weranda-options').style.display = 'none';
            document.querySelector('.modal-buttons').style.display = 'flex';
            document.getElementById('weranda-type-select').selectedIndex = 0;
        }

        // Actually add the new row
        function actuallyAddNewRow() {
            // Find the table container that contains the clicked button
            const allTableContainers = document.querySelectorAll('.table-container');
            const lastTableContainer = allTableContainers[allTableContainers.length - 1];
            const tableBody = lastTableContainer.querySelector('[id^="table-body"]');
            
            // Get the highest row number used so far
            const currentRows = tableBody.querySelectorAll('.table-row');
            let maxRowNumber = 0;
            
            currentRows.forEach(row => {
                const rowNum = parseInt(row.getAttribute('data-row-number'));
                if (rowNum > maxRowNumber) {
                    maxRowNumber = rowNum;
                }
            });
            
            const newRowNumber = maxRowNumber + 1;
            
            // Determine how many rows to add based on weranda type
            let rowCount = 1;
            let rowLabels = [''];
            
            if (isWerandaRow && currentWerandaType) {
                switch(currentWerandaType) {
                    case '2-bolek':
                        rowCount = 2;
                        rowLabels = ['2-bolek cep', '2-bolek sag'];
                        break;
                    case '3-bolek':
                        rowCount = 3;
                        rowLabels = ['3-bolek cep', '3-bolek orta', '3-bolek sag'];
                        break;
                    case '4-bolek':
                        rowCount = 4;
                        rowLabels = ['4-bolek cep', '4-bolek cep orta', '4-bolek sag orta', '4-bolek sag'];
                        break;
                }
            }
            
            // Increment weranda group counter if this is a weranda group
            let currentGroupId = null;
            if (isWerandaRow && currentWerandaType) {
                werandaGroupCounter++;
                currentGroupId = werandaGroupCounter;
            }
            
            // Add rows based on count
            for (let i = 0; i < rowCount; i++) {
                addSingleRow(tableBody, newRowNumber, rowLabels[i], currentGroupId, rowLabels);
            }
            
            if (isWerandaRow && currentWerandaType) {
                console.log(`–î–æ–±–∞–≤–ª–µ–Ω–æ ${rowCount} —Å—Ç—Ä–æ–∫ (Weranda: ${currentWerandaType}) —Å –º–µ—Ç–∫–∞–º–∏: ${rowLabels.join(', ')}, –≥—Ä—É–ø–ø–∞ ${currentGroupId}`);
            } else {
                console.log('–î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞ #' + newRowNumber);
            }
            
            // Reset weranda state
            isWerandaRow = false;
            currentWerandaType = null;
        }
        
        // Helper function to add a single row
        function addSingleRow(tableBody, rowNumber, label, groupId, allLabels = []) {
            const newRow = document.createElement('tr');
            newRow.className = 'table-row';
            newRow.setAttribute('data-row-number', rowNumber);
            
            // Mark as weranda row if applicable
            if (isWerandaRow) {
                newRow.setAttribute('data-weranda', 'true');
                newRow.setAttribute('data-weranda-type', currentWerandaType);
                if (label) {
                    newRow.setAttribute('data-weranda-label', label);
                }
                if (groupId) {
                    newRow.setAttribute('data-weranda-group', groupId);
                }
            }
            
            // Display row number with label if it's a weranda sub-row
            // Extract simple letter suffix from label for display (a, b, c, d)
            let displayNumber = rowNumber;
            if (label && allLabels.length > 0) {
                // Map label to simple letter: first item = a, second = b, etc.
                const labelIndex = allLabels.indexOf(label);
                const letterSuffix = String.fromCharCode(97 + labelIndex); // 97 = 'a'
                displayNumber = `${rowNumber}${letterSuffix}`;
            }
            
            newRow.innerHTML = `
                <td class="row-number">${displayNumber}</td>
                <td><input type="number" class="table-input" step="0.01" placeholder="0.00"></td>
                <td><input type="number" class="table-input" step="0.01" placeholder="0.00"></td>
                <td>
                    <select class="table-select karniz-select">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ...</option>
                        <option value="mata">Dine mata</option>
                        <option value="karniz_komplekt">Karniz komplekt</option>
                    </select>
                </td>
                <td>
                    <select class="table-select category-select">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ...</option>
                    </select>
                </td>
                <td>
                    <div class="searchable-select-wrapper">
                        <input type="text" class="table-input kodrenk-search" placeholder="–ù–∞—á–Ω–∏—Ç–µ –≤–≤–æ–¥–∏—Ç—å..." autocomplete="off">
                        <div class="kodrenk-dropdown"></div>
                    </div>
                </td>
                <td>
                    <select class="table-select selpe-select">
                        <option value="">-</option>
                    </select>
                </td>
                <td><input type="text" class="table-input" placeholder="–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ"></td>
                <td class="meter-square">0.00</td>
                <td class="row-price">0.00</td>
                <td>
                    <button class="remove-row-btn" onclick="removeRow(this)">‚úï</button>
                </td>
            `;
            
            tableBody.appendChild(newRow);
            
            // Setup kod renk search for new row
            const newKodRenkInput = newRow.querySelector('.kodrenk-search');
            const newKodRenkDropdown = newRow.querySelector('.kodrenk-dropdown');
            setupKodRenkSearch(newKodRenkInput, newKodRenkDropdown);
            
            // Populate category dropdown for new row and setup listener
            const newCategorySelect = newRow.querySelector('.category-select');
            populateCategorySelect(newCategorySelect);
            setupCategoryChangeListener(newCategorySelect);
            
            // Populate karniz dropdown for new row and setup listener
            const newKarnizSelect = newRow.querySelector('.karniz-select');
            populateKarnizSelect(newKarnizSelect);
            setupKarnizChangeListener(newKarnizSelect);
            
            // Populate selpe dropdown for new row
            const newSelpeSelect = newRow.querySelector('.selpe-select');
            populateSelpeSelect(newSelpeSelect);
            
            // Setup calculation listeners for the new row
            setupRowCalculationListeners(newRow);
            
            // Update table totals
            const tableContainer = newRow.closest('.table-container');
            updateTableTotals(tableContainer);
            
            // If it's a weranda row, add visual indicator in Bellik field
            if (isWerandaRow && currentWerandaType) {
                const bellikInput = newRow.querySelector('td:nth-child(8) input');
                bellikInput.value = label ? `Weranda(${label})` : `Weranda(${currentWerandaType})`;
                bellikInput.style.fontWeight = '600';
                bellikInput.style.color = '#667eea';
            }
        }

        // Function to remove row
        function removeRow(button) {
            const row = button.closest('.table-row');
            const tableBody = row.closest('tbody');
            
            // Don't allow removing if only one row remains
            if (tableBody.children.length <= 1) {
                alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É!');
                return;
            }
            
            row.remove();
            
            // Renumber rows in this specific table
            const rows = tableBody.querySelectorAll('.table-row');
            let currentNumber = 1;
            let i = 0;
            
            while (i < rows.length) {
                const currentRow = rows[i];
                const isWeranda = currentRow.getAttribute('data-weranda') === 'true';
                const werandaLabel = currentRow.getAttribute('data-weranda-label');
                
                if (isWeranda && werandaLabel) {
                    // This is a weranda row, find all rows in this group
                    const werandaType = currentRow.getAttribute('data-weranda-type');
                    let groupSize = 1;
                    
                    // Count how many consecutive weranda rows with the same type
                    while (i + groupSize < rows.length) {
                        const nextRow = rows[i + groupSize];
                        if (nextRow.getAttribute('data-weranda') === 'true' && 
                            nextRow.getAttribute('data-weranda-type') === werandaType &&
                            nextRow.getAttribute('data-weranda-label')) {
                            groupSize++;
                        } else {
                            break;
                        }
                    }
                    
                    // Assign the same number to all rows in the group
                    for (let j = 0; j < groupSize; j++) {
                        const row = rows[i + j];
                        const label = row.getAttribute('data-weranda-label');
                        row.setAttribute('data-row-number', currentNumber);
                        row.querySelector('.row-number').textContent = currentNumber + label;
                    }
                    
                    i += groupSize;
                } else {
                    // Regular row
                    currentRow.setAttribute('data-row-number', currentNumber);
                    currentRow.querySelector('.row-number').textContent = currentNumber;
                    i++;
                }
                
                currentNumber++;
            }
            
            // Update table totals after row removal
            const tableContainer = tableBody.closest('.table-container');
            updateTableTotals(tableContainer);
            
            console.log('–°—Ç—Ä–æ–∫–∞ —É–¥–∞–ª–µ–Ω–∞');
        }

        // Function to add new table - opens modal for user data
        function addNewTable() {
            // Open modal to get user data for new table
            openUserDataModalForNewTable();
        }
        
        // Open user data modal for new table
        function openUserDataModalForNewTable() {
            const modal = document.getElementById('user-data-modal');
            modal.classList.add('show');
            modal.setAttribute('data-new-table', 'true');
        }
        
        // Modified confirmUserData to handle both first table and new tables
        function confirmUserData() {
            if (!modalSelectedUser) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!');
                return;
            }
            
            const modal = document.getElementById('user-data-modal');
            const isNewTable = modal.getAttribute('data-new-table') === 'true';
            
            // Get selected currency
            const currencySelect = document.getElementById('modal-currency-select');
            modalSelectedCurrency = currencySelect.value;
            console.log('Selected currency from modal:', modalSelectedCurrency);
            
            if (isNewTable) {
                // Creating a new table
                modal.removeAttribute('data-new-table');
                actuallyAddNewTable();
            } else {
                // Creating first table
                const tableNumber = 1;
                currentTableUserData[tableNumber] = {
                    user: modalSelectedUser,
                    region: modalRegionDisplay.value,
                    currency: modalSelectedCurrency
                };
                console.log('Saved user data for table 1:', currentTableUserData[tableNumber]);
                
                // Hide initial button
                document.getElementById('initial-add-container').style.display = 'none';
                
                // Show tables wrapper
                document.getElementById('tables-wrapper').style.display = 'block';
                
                // Show first table
                const firstTable = document.querySelector('.table-container[data-table-number="1"]');
                firstTable.style.display = 'block';
                
                // Add user data display to table
                addUserDataToTable(firstTable, tableNumber);
                
                // Update table totals to show correct currency
                updateTableTotals(firstTable);
                
                closeUserDataModal();
                console.log('–ü–µ—Ä–≤—ã–π –∑–∞–∫–∞–∑ —Å–æ–∑–¥–∞–Ω —Å –¥–∞–Ω–Ω—ã–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
            }
        }
        
        // Actually add new table with user data
        function actuallyAddNewTable() {
            const mainContainer = document.querySelector('.container');
            const allTableContainers = document.querySelectorAll('.table-container');
            const lastTableContainer = allTableContainers[allTableContainers.length - 1];
            
            // Get the next table number
            const lastTableNumber = parseInt(lastTableContainer.getAttribute('data-table-number'));
            const newTableNumber = lastTableNumber + 1;
            
            // Store user data for this new table
            currentTableUserData[newTableNumber] = {
                user: modalSelectedUser,
                region: modalRegionDisplay.value,
                currency: modalSelectedCurrency
            };
            console.log('Saved user data for table', newTableNumber, ':', currentTableUserData[newTableNumber]);
            
            // Remove buttons from current table
            const currentButtons = lastTableContainer.querySelector('.table-buttons');
            currentButtons.remove();
            
            // Clone the last table container (without buttons now)
            const newTableContainer = lastTableContainer.cloneNode(true);
            
            // Update table number
            newTableContainer.setAttribute('data-table-number', newTableNumber);
            const tableTitle = newTableContainer.querySelector('.table-title');
            tableTitle.textContent = '–ó–∞–∫–∞–∑ ‚Ññ' + newTableNumber;
            
            // Get all rows in the new table and keep only the first one
            const newTableBody = newTableContainer.querySelector('[id^="table-body"]');
            const rows = newTableBody.querySelectorAll('.table-row');
            
            // Remove all rows except the first one
            for (let i = 1; i < rows.length; i++) {
                rows[i].remove();
            }
            
            // Reset the first row's inputs
            const inputs = newTableBody.querySelectorAll('input');
            inputs.forEach(input => {
                if (input.type === 'number') {
                    input.value = '';
                } else {
                    input.value = '';
                }
            });
            
            // Reset selects
            const selects = newTableBody.querySelectorAll('select');
            selects.forEach(select => {
                select.selectedIndex = 0;
            });
            
            // Reset row number
            newTableBody.querySelector('.row-number').textContent = '1';
            newTableBody.querySelector('.table-row').setAttribute('data-row-number', '1');
            
            // Update IDs to be unique
            const newTable = newTableContainer.querySelector('[id^="order-table"]');
            const timestamp = Date.now();
            newTable.id = 'order-table-' + timestamp;
            newTableBody.id = 'table-body-' + timestamp;
            
            // Setup kod renk search for the new table
            const kodRenkInputs = newTableContainer.querySelectorAll('.kodrenk-search');
            kodRenkInputs.forEach((input) => {
                const dropdown = input.nextElementSibling;
                setupKodRenkSearch(input, dropdown);
            });
            
            // Setup category change listeners for the new table
            const categorySelects = newTableContainer.querySelectorAll('.category-select');
            categorySelects.forEach((select) => {
                setupCategoryChangeListener(select);
            });
            
            // Reset total prices for the new table
            const totalDisplay = newTableContainer.querySelector('.total-price-value');
            if (totalDisplay) totalDisplay.textContent = '0.00';
            
            // Setup calculation listeners for all rows in the new table
            const newTableRows = newTableBody.querySelectorAll('tr');
            newTableRows.forEach(row => setupRowCalculationListeners(row));
            
            // Add buttons back to the new table
            newTableContainer.appendChild(currentButtons);
            
            // Insert the new table after the last table container
            lastTableContainer.parentNode.insertBefore(newTableContainer, lastTableContainer.nextSibling);
            
            // Add user data display to new table
            addUserDataToTable(newTableContainer, newTableNumber);
            
            // Update table totals to show correct currency
            updateTableTotals(newTableContainer);
            
            closeUserDataModal();
            console.log('–î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞: –ó–∞–∫–∞–∑ ‚Ññ' + newTableNumber);
        }

        // Function to delete table
        function deleteTable(button) {
            const allTableContainers = document.querySelectorAll('.table-container');
            
            // Don't allow deleting if only one table remains
            if (allTableContainers.length <= 1) {
                alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–∞–±–ª–∏—Ü—É!');
                return;
            }
            
            const tableContainer = button.closest('.table-container');
            const hasButtons = tableContainer.querySelector('.table-buttons') !== null;
            
            // If this table has the buttons, move them to the last remaining table
            if (hasButtons) {
                const buttons = tableContainer.querySelector('.table-buttons');
                buttons.remove();
                
                // Find a table to move buttons to (preferably the previous one, or the next one)
                let targetTable = tableContainer.previousElementSibling;
                if (!targetTable || !targetTable.classList.contains('table-container')) {
                    targetTable = tableContainer.nextElementSibling;
                }
                
                if (targetTable && targetTable.classList.contains('table-container')) {
                    targetTable.appendChild(buttons);
                }
            }
            
            // Remove the table
            const tableNumber = tableContainer.getAttribute('data-table-number');
            tableContainer.remove();
            
            console.log('–£–¥–∞–ª–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞: –ó–∞–∫–∞–∑ ‚Ññ' + tableNumber);
        }
        
        // Function to download data as Excel file
        function downloadAsExcel() {
            console.log('Starting Excel download...');
            
            try {
                // Collect all form data
                const formData = collectAllFormData();
                console.log('Form data collected:', formData);
                
                // Create workbook
                const wb = XLSX.utils.book_new();
                
                // Combine all orders into one sheet with page breaks
                const allOrdersData = [];
                const pageBreaks = [];
                let currentRow = 0;
                
                formData.orders.forEach((order, index) => {
                    const orderData = generateExcelSheetData(order, formData);
                    
                    // Add order data
                    allOrdersData.push(...orderData);
                    currentRow += orderData.length;
                    
                    // Add page break after each order (except the last one)
                    if (index < formData.orders.length - 1) {
                        pageBreaks.push(currentRow);
                        // Add spacing between orders
                        allOrdersData.push([]);
                        allOrdersData.push([]);
                        currentRow += 2;
                    }
                });
                
                // Create worksheet from combined data
                const ws = XLSX.utils.aoa_to_sheet(allOrdersData);
                
                // Set column widths (9 columns now)
                ws['!cols'] = [
                    {wch: 6},  // ‚Ññ
                    {wch: 8},  // Ini
                    {wch: 8},  // Boyy
                    {wch: 12}, // Karniz
                    {wch: 12}, // Kod Renk
                    {wch: 10}, // Selpe
                    {wch: 18}, // Bellik
                    {wch: 8},  // m¬≤
                    {wch: 14}  // Price (USD or TMT)
                ];
                
                // Set page breaks
                ws['!rows'] = ws['!rows'] || [];
                pageBreaks.forEach(breakRow => {
                    ws['!rows'][breakRow] = ws['!rows'][breakRow] || {};
                    ws['!rows'][breakRow].pageBreak = true;
                });
                
                // Apply styling to the combined sheet
                applyExcelStylingCombined(ws, formData.orders);
                
                // Merge cells for title and user info
                ws['!merges'] = [];
                let rowOffset = 0;
                formData.orders.forEach((order, index) => {
                    const userData = currentTableUserData[order.orderNumber];
                    
                    // Merge –ó–ê–ö–ê–ó title cells (columns 0-1)
                    ws['!merges'].push({
                        s: { r: rowOffset, c: 0 },
                        e: { r: rowOffset, c: 1 }
                    });
                    
                    // Merge user name cells (columns 3-4) if user data exists
                    // Row structure: –ó–ê–ö–ê–ó ‚ÑñX (0-1) | User: (2) | Name (3-4) | Region: (5) | Region value (6)
                    if (userData) {
                        ws['!merges'].push({
                            s: { r: rowOffset, c: 3 },
                            e: { r: rowOffset, c: 4 }
                        });
                    }
                    
                    const headerInfoRows = 1; // Title and user info on same row
                    const headerRow = 1;
                    const dataRows = order.rows.length;
                    const totalRows = 1; // Only one –ò–¢–û–ì–û row now
                    const spacingRows = index < formData.orders.length - 1 ? 2 : 0;
                    
                    // Merge total row cells (columns 7-8) for "–ò–¢–û–ì–û (currency): value"
                    const totalRowIndex = rowOffset + headerInfoRows + headerRow + dataRows;
                    ws['!merges'].push({
                        s: { r: totalRowIndex, c: 7 },
                        e: { r: totalRowIndex, c: 8 }
                    });
                    
                    rowOffset += headerInfoRows + headerRow + dataRows + totalRows + spacingRows;
                });
                
                // Set print options for better page layout
                ws['!print'] = {
                    orientation: 'landscape',
                    margins: {
                        left: 0.25,
                        right: 0.25,
                        top: 0.75,
                        bottom: 0.75,
                        header: 0.3,
                        footer: 0.3
                    },
                    fitToPage: true,
                    fitToWidth: 1,
                    fitToHeight: 0
                };
                
                // Add sheet with date in name
                const currentDate = new Date().toISOString().split('T')[0];
                const sheetName = `Orders ${currentDate}`;
                XLSX.utils.book_append_sheet(wb, ws, sheetName);
                
                // Generate file and download
                const fileName = `Sargyt_${currentDate}.xlsx`;
                XLSX.writeFile(wb, fileName, {
                    bookType: 'xlsx'
                });
                
                // Also save file to server
                try {
                    // Generate file as array buffer
                    const wbout = XLSX.write(wb, {
                        bookType: 'xlsx',
                        type: 'array'
                    });
                    
                    // Convert to base64
                    const blob = new Blob([wbout], {type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
                    const reader = new FileReader();
                    
                    reader.onloadend = async function() {
                        const base64data = reader.result;
                        
                        // Send to server
                        try {
                            const response = await fetch('/api/save-excel/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    file_data: base64data,
                                    file_name: fileName
                                })
                            });
                            
                            const result = await response.json();
                            
                            if (result.success) {
                                console.log('File saved to server with UUID:', result.check_uuid);
                            } else {
                                console.error('Error saving file to server:', result.error);
                            }
                        } catch (error) {
                            console.error('Error sending file to server:', error);
                        }
                    };
                    
                    reader.readAsDataURL(blob);
                } catch (error) {
                    console.error('Error saving file to server:', error);
                }
                
                console.log('Excel file downloaded with styling');
                alert('Excel —Ñ–∞–π–ª —Å–∫–∞—á–∞–Ω!');
                
            } catch (error) {
                console.error('Error downloading Excel file:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏: ' + error.message);
            }
        }
        
        // Apply beautiful minimalistic styling to combined Excel sheet
        function applyExcelStylingCombined(ws, orders) {
            const range = XLSX.utils.decode_range(ws['!ref']);
            let currentRow = 0;
            
            orders.forEach((order, orderIndex) => {
                const userData = currentTableUserData[order.orderNumber];
                let headerRowIndex = currentRow;
                
                // Style combined title and user info row
                // Row structure: –ó–ê–ö–ê–ó ‚ÑñX (0-1) | User: (2) | Name (3-4) | Region: (5) | Region value (6)
                for (let col = 0; col < 7; col++) {
                    const cellRef = XLSX.utils.encode_cell({r: currentRow, c: col});
                    if (ws[cellRef]) {
                        ws[cellRef].s = {
                            font: {
                                name: 'Calibri',
                                sz: 11,
                                bold: col === 0 || col === 2 || col === 5, // Bold for "–ó–ê–ö–ê–ó", "User:" and "Region:" labels
                                color: { rgb: '2C3E50' }
                            },
                            alignment: {
                                vertical: 'center',
                                horizontal: (col === 2 || col === 5) ? 'right' : 'left' // All left except User: and Region: labels
                            }
                        };
                    }
                }
                ws['!rows'] = ws['!rows'] || [];
                ws['!rows'][currentRow] = { hpt: 20 };
                currentRow += 1; // Combined title and user info row
                headerRowIndex = currentRow;
                
                // Style header row
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellRef = XLSX.utils.encode_cell({r: headerRowIndex, c: col});
                    // Create cell if it doesn't exist
                    if (!ws[cellRef]) {
                        ws[cellRef] = { v: '', t: 's' };
                    }
                    
                    ws[cellRef].s = {
                        font: {
                            name: 'Calibri',
                            sz: 12,
                            bold: true,
                            color: { rgb: '000000' }
                        },
                        alignment: {
                            vertical: 'center',
                            horizontal: 'center'
                        },
                        border: {
                            top: { style: 'thin', color: { rgb: '000000' } },
                            bottom: { style: 'medium', color: { rgb: '000000' } },
                            left: { style: 'thin', color: { rgb: '000000' } },
                            right: { style: 'thin', color: { rgb: '000000' } }
                        }
                    };
                }
                
                // Set row height for header (once, outside column loop)
                ws['!rows'] = ws['!rows'] || [];
                ws['!rows'][headerRowIndex] = { hpt: 25 };
                
                currentRow += 1; // Header row
                
                // Style data rows
                const dataRowCount = order.rows.length;
                for (let i = 0; i < dataRowCount; i++) {
                    const row = currentRow + i;
                    const isEven = i % 2 === 0;
                    const rowData = [];
                    
                    // Get row data to check for weranda
                    for (let col = range.s.c; col <= range.e.c; col++) {
                        const cellRef = XLSX.utils.encode_cell({r: row, c: col});
                        if (ws[cellRef]) {
                            rowData.push(ws[cellRef].v);
                        }
                    }
                    
                    const isWerandaRow = rowData[7] && String(rowData[7]).includes('Weranda');
                    
                    for (let col = range.s.c; col <= range.e.c; col++) {
                        const cellRef = XLSX.utils.encode_cell({r: row, c: col});
                        // Create cell if it doesn't exist
                        if (!ws[cellRef]) {
                            ws[cellRef] = { v: '', t: 's' };
                        }
                        
                        ws[cellRef].s = {
                            font: {
                                name: 'Calibri',
                                sz: 11,
                                color: { rgb: '2C3E50' }
                            },
                            alignment: {
                                vertical: 'center',
                                horizontal: 'center'
                            },
                            border: {
                                top: { style: 'thin', color: { rgb: '000000' } },
                                bottom: { style: 'thin', color: { rgb: '000000' } },
                                left: { style: 'thin', color: { rgb: '000000' } },
                                right: { style: 'thin', color: { rgb: '000000' } }
                            },
                            numFmt: col === 1 || col === 2 ? '0.00' : '@'
                        };
                        // Set row height for data
                        ws['!rows'] = ws['!rows'] || [];
                        ws['!rows'][row] = ws['!rows'][row] || { hpt: 20 };
                    }
                }
                
                currentRow += dataRowCount;
                
                // Style total row (only 1 total row now, 9 columns)
                // Columns 7-8 are merged for total
                for (let col = 0; col <= 8; col++) {
                    const cellRef = XLSX.utils.encode_cell({r: currentRow, c: col});
                    // Create cell if it doesn't exist
                    if (!ws[cellRef]) {
                        ws[cellRef] = { v: '', t: 's' };
                    }
                    
                    ws[cellRef].s = {
                        font: {
                            name: 'Calibri',
                            sz: 12,
                            bold: col >= 7, // Bold for merged total cell (columns 7-8)
                            color: { rgb: col >= 7 ? '1A1A1A' : '2C3E50' }
                        },
                        alignment: {
                            vertical: 'center',
                            horizontal: col >= 7 ? 'right' : 'center' // Right align merged total cell
                        },
                        fill: col >= 7 ? {
                            fgColor: { rgb: 'F8F9FA' } // Light background for total
                        } : undefined
                    };
                }
                // Set row height for total row
                ws['!rows'] = ws['!rows'] || [];
                ws['!rows'][currentRow] = { hpt: 25 };
                currentRow += 1;
                
                // Skip empty spacing rows between orders
                if (orderIndex < orders.length - 1) {
                    currentRow += 2;
                }
            });
        }
        
        // Apply beautiful minimalistic styling to Excel sheet
        function applyExcelStyling(ws, order) {
            const range = XLSX.utils.decode_range(ws['!ref']);
            
            // Determine header row (user info or not)
            const userData = currentTableUserData[order.orderNumber];
            const headerRowIndex = userData ? 3 : 0; // Row with column headers
            
            // Style for user info section (if exists)
            if (userData) {
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col <= 1; col++) {
                        const cellRef = XLSX.utils.encode_cell({r: row, c: col});
                        if (ws[cellRef]) {
                            ws[cellRef].s = {
                                font: {
                                    name: 'Calibri',
                                    sz: 11,
                                    bold: col === 0,
                                    color: { rgb: '2C3E50' }
                                },
                                alignment: {
                                    vertical: 'center',
                                    horizontal: col === 0 ? 'right' : 'left'
                                },
                                fill: {
                                    fgColor: { rgb: 'F8F9FA' }
                                }
                            };
                        }
                    }
                }
            }
            
            // Style header row with minimalistic design
            for (let col = range.s.c; col <= range.e.c; col++) {
                const cellRef = XLSX.utils.encode_cell({r: headerRowIndex, c: col});
                if (ws[cellRef]) {
                    ws[cellRef].s = {
                        font: {
                            name: 'Calibri',
                            sz: 12,
                            bold: true,
                            color: { rgb: 'FFFFFF' }
                        },
                        fill: {
                            fgColor: { rgb: '495057' } // Minimal dark gray
                        },
                        alignment: {
                            vertical: 'center',
                            horizontal: 'center'
                        },
                        border: {
                            top: { style: 'thin', color: { rgb: '000000' } },
                            bottom: { style: 'medium', color: { rgb: '000000' } },
                            left: { style: 'thin', color: { rgb: '000000' } },
                            right: { style: 'thin', color: { rgb: '000000' } }
                        }
                    };
                }
            }
            
            // Style data rows with alternating subtle colors
            for (let row = headerRowIndex + 1; row <= range.e.r; row++) {
                const isEven = (row - headerRowIndex) % 2 === 0;
                const rowData = [];
                
                // Check if this is a weranda row
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellRef = XLSX.utils.encode_cell({r: row, c: col});
                    if (ws[cellRef]) {
                        rowData.push(ws[cellRef].v);
                    }
                }
                
                const isWerandaRow = rowData[7] && String(rowData[7]).includes('Weranda');
                
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellRef = XLSX.utils.encode_cell({r: row, c: col});
                    if (ws[cellRef]) {
                        ws[cellRef].s = {
                            font: {
                                name: 'Calibri',
                                sz: 11,
                                color: { rgb: '2C3E50' }
                            },
                            fill: {
                                fgColor: { 
                                    rgb: isWerandaRow ? 'E3F2FD' : // Light blue for weranda
                                         isEven ? 'FFFFFF' : 'F8F9FA' // Alternating white/light gray
                                }
                            },
                            alignment: {
                                vertical: 'center',
                                horizontal: col === 0 ? 'center' : // Center row number
                                          col === 1 || col === 2 ? 'right' : // Right align numbers
                                          'left'
                            },
                            border: {
                                top: { style: 'thin', color: { rgb: '000000' } },
                                bottom: { style: 'thin', color: { rgb: '000000' } },
                                left: { style: 'thin', color: { rgb: '000000' } },
                                right: { style: 'thin', color: { rgb: '000000' } }
                            },
                            numFmt: col === 1 || col === 2 ? '0.00' : '@' // Format numbers with 2 decimals
                        };
                    }
                }
            }
            
            // Set row heights for better spacing
            ws['!rows'] = [];
            for (let i = 0; i <= range.e.r; i++) {
                if (i === headerRowIndex) {
                    ws['!rows'][i] = { hpt: 25 }; // Header row height
                } else {
                    ws['!rows'][i] = { hpt: 20 }; // Data row height
                }
            }
        }
        
        // Generate Excel sheet data for an order
        function generateExcelSheetData(order, formData) {
            const data = [];
            
            // Add header info on one line with order number
            // Structure: –ó–ê–ö–ê–ó ‚ÑñX (0-1 merged) | User: (2) | Name (3-4 merged) | Region: (5) | Region value (6)
            const userData = currentTableUserData[order.orderNumber];
            if (userData) {
                data.push([`–ó–ê–ö–ê–ó ‚Ññ${order.orderNumber}`, '', 'User:', userData.user.name, '', 'Region:', userData.region]);
            } else {
                data.push([`–ó–ê–ö–ê–ó ‚Ññ${order.orderNumber}`]);
            }
            
            // Get currency for this order
            const currency = userData && userData.currency ? userData.currency : 'USD';
            
            // Add table headers (9 columns now - removed one price column)
            data.push(['‚Ññ', 'Ini', 'Boyy', 'Karniz', 'Kod Renk', 'Selpe', 'Bellik', 'm¬≤', `Price (${currency})`]);
            
            // Add rows (ensure all have 9 columns)
            order.rows.forEach(row => {
                data.push([
                    row.number || '',
                    row.en || '',
                    row.boy || '',
                    row.karniz || '',
                    row.kodRenk || '',
                    row.selpe || '',
                    row.bellik || '',
                    row.meterSquare || '0.00',
                    row.price ? row.price.toFixed(2) : '0.00'
                ]);
            });
            
            // Add total price (9 columns: 6 empty + merged cell with label and value)
            const totalValue = order.total ? order.total.toFixed(2) : '0.00';
            const totalText = `–ò–¢–û–ì–û (${currency}): ${totalValue}`;
            data.push(['', '', '', '', '', '', '', totalText, '']);
            
            return data;
        }
        
        // Collect all form data from the page
        function collectAllFormData() {
            const data = {
                orders: []
            };
            
            // Get all tables
            const tables = document.querySelectorAll('.table-container');
            
            tables.forEach((tableContainer, tableIndex) => {
                const orderData = {
                    orderNumber: tableIndex + 1,
                    rows: []
                };
                
                // Get all rows from the table
                const rows = tableContainer.querySelectorAll('.table-row');
                
                // Get client type and currency for this table
                const clientType = getClientTypeForTable(tableContainer);
                const currency = getCurrencyForTable(tableContainer);
                
                let orderTotal = 0;
                
                rows.forEach((row) => {
                    // Calculate row price
                    const rowPrice = calculateRowPrice(row, clientType);
                    orderTotal += rowPrice;
                    
                    const rowData = {
                        number: row.querySelector('.row-number').textContent,
                        en: row.querySelector('td:nth-child(2) input').value,
                        boy: row.querySelector('td:nth-child(3) input').value,
                        karniz: row.querySelector('.karniz-select').selectedOptions[0]?.text || '',
                        category: row.querySelector('.category-select').selectedOptions[0]?.text || '',
                        kodRenk: row.querySelector('.kodrenk-search').value,
                        selpe: row.querySelector('.selpe-select').selectedOptions[0]?.text || '',
                        bellik: row.querySelector('td:nth-child(8) input').value,
                        meterSquare: row.querySelector('.meter-square')?.textContent || '0.00',
                        price: rowPrice,
                        isWeranda: row.getAttribute('data-weranda') === 'true',
                        werandaType: row.getAttribute('data-weranda-type') || '',
                        werandaLabel: row.getAttribute('data-weranda-label') || ''
                    };
                    
                    orderData.rows.push(rowData);
                });
                
                // Add total to order data
                orderData.total = orderTotal;
                orderData.currency = currency;
                
                data.orders.push(orderData);
            });
            
            return data;
        }
    </script>
</body>
</html>
